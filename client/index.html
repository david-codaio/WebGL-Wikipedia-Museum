<!DOCTYPE html>
<html>
<head>
<title>Wikipedia Art Gallery</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="includes/wag.css" type="text/css" />

<script type="text/javascript" src="http://code.jquery.com/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="includes/sylvester.js"></script>
<script type="text/javascript" src="includes/glUtils.js"></script>

<script type="text/javascript" src="includes/Room.js"></script>
<script type="text/javascript" src="includes/Matrix.js"></script>
<script type="text/javascript" src="includes/Movement.js"></script>
<script type="text/javascript" src="includes/WAG.js"></script>

<script type="text/javascript">
  var WAGinstance;
  var room;
  var gl;

  var currentProgram;
  var perVertexProgram;
  var perFragmentProgram;
  var spotlightProgram;

  var WAGConfig = {
    programs: {
      perVertex: {
        fragment: "includes/shader-fs.frag",
        vertex:   "includes/shader-vs.vert"
      },
      perFragment: {
        fragment: "includes/lighting-fs.frag",
        vertex:   "includes/lighting-vs.vert"
      },
      spotlight: {
        fragment: "includes/spotlight-fs.frag",
        vertex:   "includes/spotlight-vs.vert"
      }
    }
  }

  function getShader(gl, id, shader_type, cb) {
    var shaderScript = WAGConfig.programs[id];
    if (!shaderScript) {
      return null;
    }
    
    $.ajax({
      url: shaderScript[shader_type],
      dataType: "text",
      success: function(data) {
        var shader;
        if (shader_type == "fragment") {
          shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shader_type == "vertex") {
          shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
          cb(null);
        }
        
        gl.shaderSource(shader, data);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Error compiling shader: "+gl.getShaderInfoLog(shader));
          cb(null);
        }
        
        cb(shader);
      },
      error: function(xhr, textStatus, errorThrown) {
        console.error("Error: Unable to get shader "+id);
      }
    });
  }
  
  function createProgram(program_id, cb) {
    getShader(gl, program_id, "fragment", function(fragmentShader) {
      getShader(gl, program_id, "vertex", function(vertexShader) {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          alert("Could not initialise shaders");
        }
    
        program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
        gl.enableVertexAttribArray(program.vertexPositionAttribute);
    
        program.vertexNormalAttribute = gl.getAttribLocation(program, "aVertexNormal");
        gl.enableVertexAttribArray(program.vertexNormalAttribute);
    
        program.textureCoordAttribute = gl.getAttribLocation(program, "aTextureCoord");
        gl.enableVertexAttribArray(program.textureCoordAttribute);
    
        program.pMatrixUniform = gl.getUniformLocation(program, "uPMatrix");
        program.mvMatrixUniform = gl.getUniformLocation(program, "uMVMatrix");
        program.nMatrixUniform = gl.getUniformLocation(program, "uNMatrix");
        program.samplerUniform = gl.getUniformLocation(program, "uSampler");
        program.useTexturesUniform = gl.getUniformLocation(program, "uUseTextures");
        program.useLightingUniform = gl.getUniformLocation(program, "uUseLighting");
        program.ambientColorUniform = gl.getUniformLocation(program, "uAmbientColor");
        program.spotCosCutoffUniform = gl.getUniformLocation(program, "uSpotCosCutoff");
        program.cosInnerConeAngleUniform = gl.getUniformLocation(program, "uCosInnerConeAngle");
        program.cosOuterConeAngleUniform = gl.getUniformLocation(program, "uCosOuterConeAngle");
        program.pointLightingLocationUniform = gl.getUniformLocation(program, "uPointLightingLocation");
        program.pointLightingColorUniform = gl.getUniformLocation(program, "uPointLightingColor");
        program.pointLightingDirectionUniform = gl.getUniformLocation(program, "uPointLightingDirection");

        cb(program);
      });
    });
  }

  function setMatrixUniforms() {
    gl.uniformMatrix4fv(currentProgram.pMatrixUniform, false, new Float32Array(pMatrix.flatten()));
    gl.uniformMatrix4fv(currentProgram.mvMatrixUniform, false, new Float32Array(mvMatrix.flatten()));

    var normalMatrix = mvMatrix.inverse();
    normalMatrix = normalMatrix.transpose();
    gl.uniformMatrix4fv(currentProgram.nMatrixUniform, false, new Float32Array(normalMatrix.flatten()));
  }

  function drawScene() {
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    if (room.walls.textureCoordBuffer == null ||
        room.walls.normalBuffer == null ||
        room.walls.positionBuffer == null ||
        room.floor.textureCoordBuffer == null ||
        room.floor.normalBuffer == null ||
        room.floor.positionBuffer == null) {
      return;
    }

    perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);

    if (document.getElementById("per-fragment-radio").checked) {
      currentProgram = perFragmentProgram;
    } else if (document.getElementById("per-vertex-radio").checked) {
      currentProgram = perVertexProgram;
    } else if (document.getElementById("spotlight-radio").checked) {
      currentProgram = spotlightProgram;
    }
    gl.useProgram(currentProgram);


    var lighting = document.getElementById("lighting").checked;
    gl.uniform1i(currentProgram.useLightingUniform, lighting);
    if (lighting) {
      gl.uniform3f(
        currentProgram.ambientColorUniform,
        parseFloat(document.getElementById("ambientR").value),
        parseFloat(document.getElementById("ambientG").value),
        parseFloat(document.getElementById("ambientB").value)
      );

      gl.uniform3f(
        currentProgram.pointLightingLocationUniform,
        parseFloat(document.getElementById("lightPositionX").value),
        parseFloat(document.getElementById("lightPositionY").value),
        parseFloat(document.getElementById("lightPositionZ").value)
      );

      gl.uniform3f(
        currentProgram.pointLightingColorUniform,
        parseFloat(document.getElementById("pointR").value),
        parseFloat(document.getElementById("pointG").value),
        parseFloat(document.getElementById("pointB").value)
      );
      
      gl.uniform3f(
        currentProgram.pointLightingDirectionUniform,
        parseFloat(document.getElementById("directionX").value),
        parseFloat(document.getElementById("directionY").value),
        parseFloat(document.getElementById("directionZ").value)
      );
      
      gl.uniform1f(
        currentProgram.spotCosCutoffUniform,
        parseFloat(document.getElementById("spotCosCutoff").value)
      );
      
      gl.uniform1f(
        currentProgram.cosInnerConeAngleUniform,
        parseFloat(document.getElementById("cos_inner_cone_angle").value)
      );
      
      gl.uniform1f(
        currentProgram.cosOuterConeAngleUniform,
        parseFloat(document.getElementById("cos_outer_cone_angle").value)
      );
    }

    var textures = document.getElementById("textures").checked;
    gl.uniform1i(currentProgram.useTexturesUniform, textures);

    loadIdentity();
    
    mvRotate(-pitch, [1, 0, 0]);
    mvRotate(-yaw, [0, 1, 0]);
    mvTranslate([-xPos, -yPos, -zPos]);

    room.renderComponents();
  }

  $(document).ready(function() {
    room = new Room(function() {
      $('#loadingtext').hide();
    });

    WAGinstance = new WAG("wagCanvas");
    WAGinstance.initialize();
  });
</script>
</head>

<body>
  <canvas id="wagCanvas" style="border: none;" width="800" height="500"></canvas>

  <div id="loadingtext">Loading world...</div>

  <br/>
Use the cursor keys or WASD to run around, and <code>Page Up</code>/<code>Page Down</code> to
look up and down.<br/>
  <br/>

<input type="checkbox" id="lighting" checked="checked" /> Use lighting
<input type="checkbox" id="textures" checked="checked" /> Use textures
Shader program:
<input type="radio" name="shader" id="per-vertex-radio" value="per-vertex" /> Per-vertex
<input type="radio" name="shader" id="per-fragment-radio" value="per-fragment" checked="checked" /> Per-fragment
<input type="radio" name="shader" id="spotlight-radio" value="spotlight" /> Spotlight
<br/>

<table id="parameterTable">
<tr>
<th>Position:</th>
<td>X: <input type="text" id="lightPositionX" value="-0.25" /></td>
<td>Y: <input type="text" id="lightPositionY" value="0.5" /></td>
<td>Z: <input type="text" id="lightPositionZ" value="-1.0" /></td>
</tr>
<tr>
<th>Colour:</th>
<td>R: <input type="text" id="pointR" value="0.8" /></td>
<td>G: <input type="text" id="pointG" value="0.8" /></td>
<td>B: <input type="text" id="pointB" value="0.8" /></td>
</tr>
<tr>
<th>Ambient Colour:</th>
<td>R: <input type="text" id="ambientR" value="0.2" /></td>
<td>G: <input type="text" id="ambientG" value="0.2" /></td>
<td>B: <input type="text" id="ambientB" value="0.2" /></td>
</tr>
<tr>
<th>Spotlight Direction:</th>
<td>X: <input type="text" id="directionX" value="0.2" /></td>
<td>Y: <input type="text" id="directionY" value="0.2" /></td>
<td>Z: <input type="text" id="directionZ" value="0.2" /></td>
</tr>
<tr>
<th>Spotlight Params:</th>
<td>spotCosCutoff: <input type="text" id="spotCosCutoff" value="0.2" /></td>
<td>Cos Inner Cone Angle: <input type="text" id="cos_inner_cone_angle" value="0.2" /></td>
<td>Cos Outer Cone Angle: <input type="text" id="cos_outer_cone_angle" value="0.2" /></td>
</tr>
</table>

</body>

</html>
